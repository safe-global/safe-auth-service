import uuid
from datetime import timedelta
from typing import cast

from fastapi import HTTPException

import bcrypt
from starlette import status

from ..config import settings
from ..datasources.cache.redis import get_redis
from ..datasources.db.models import User
from ..datasources.email.email_client import EmailClient
from ..models.users import Token
from .jwt_service import JwtService


class UserServiceException(Exception):
    pass


class TemporaryTokenNotValid(UserServiceException):
    pass


class UserAlreadyExists(UserServiceException):
    pass


class UserNotFound(UserServiceException):
    pass


class TemporaryTokenExists(UserServiceException):
    pass


class UserService:
    TEMPORARY_TOKEN_REGISTRATION_PREFIX = "temporary-token:registrations:"

    def __init__(self):
        self.email_client = EmailClient()
        self.jwt_service = JwtService()

    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        return bcrypt.checkpw(plain_password.encode(), hashed_password.encode())

    def hash_password(self, password: str) -> str:
        """
        Args:
            password:

        Returns:
            A string like '$2b$12$yadYxE5ZNfF28M.M00gha.SEaPF2Z.ICEqgIhbhZrgCrCR7PEK7uS'
        """
        return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()

    def temporary_token_generate(
        self,
        key_prefix: str,
        email: str,
        ttl_seconds: int = settings.PRE_REGISTRATION_TOKEN_TTL_SECONDS,
    ) -> str:
        """
        Generates a temporary token and stores it in the cache for an email

        Returns:
            Temporary token
        """
        token = uuid.uuid4().hex
        get_redis().set(key_prefix + email, token, ex=ttl_seconds)
        return token

    def temporary_token_is_valid(self, key_prefix: str, email: str, token: str) -> bool:
        """
        Checks whether a temporary token is valid for a given email

        Returns:
            `True` if the token is valid
        """
        cached_token = cast(bytes, get_redis().get(key_prefix + email))
        return bool(cached_token and cached_token.decode() == token)

    def temporary_token_exists(self, key_prefix: str, email: str) -> bool:
        """
        Args:
            email:

        Returns:
            ``True`` if a temporary token exists for the provided email
        """
        return cast(bool, get_redis().exists(key_prefix + email))

    def pre_register_user(self, email: str) -> str:
        """
        Args:
            email:

        Returns:
            A temporary token that can be used to register a new user.

        Raises:
            TemporaryTokenExists: if a temporary token already exists for the email
        """

        if self.temporary_token_exists(self.TEMPORARY_TOKEN_REGISTRATION_PREFIX, email):
            raise TemporaryTokenExists(f"Temporary token exists for {email}")
        token = self.temporary_token_generate(
            self.TEMPORARY_TOKEN_REGISTRATION_PREFIX, email
        )
        self.email_client.send_temporary_token_email(email, token)
        return token

    async def register_user(self, email: str, password: str, token: str) -> str:
        """
        Args:
            email:
            password:
            token: Temporary token generated by `pre_register_user`

        Returns:
            UUID4 of the registered user

        Raises:
            TemporaryTokenNotValid: if the temporary token is not valid
            UserAlreadyExists: user with the provided email exists in the database
        """

        if not self.temporary_token_is_valid(
            self.TEMPORARY_TOKEN_REGISTRATION_PREFIX, email, token
        ):
            raise TemporaryTokenNotValid(f"Temporary token not valid for {email}")
        if await User.get_by_email(email):
            raise UserAlreadyExists(f"User with email {email} already exists")
        hashed_password = self.hash_password(password)
        user_uuid = uuid.uuid4().hex
        user = User(id=user_uuid, email=email, hashed_password=hashed_password)
        await user.create()
        return user_uuid

    async def authenticate_user(self, email: str, password: str) -> User | None:
        user = await User.get_by_email(email)
        if user and self.verify_password(password, user.hashed_password):
            return user
        return None

    async def login_user(self, email: str, password: str) -> Token:
        user = await self.authenticate_user(email, password)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(days=settings.JWT_AUTH_SERVICE_EXPIRE_DAYS)
        access_token = self.jwt_service.create_access_token(
            user.id.hex, access_token_expires, settings.JWT_AUDIENCE, {}
        )
        return Token(access_token=access_token, token_type="bearer")
