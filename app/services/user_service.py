import uuid
from typing import cast

import bcrypt

from ..config import settings
from ..datasources.cache.redis import get_redis
from ..datasources.db.models import Users
from ..datasources.email.email_provider import EmailProvider


class TemporaryTokenNotValid(Exception):
    pass


class TemporaryTokenExists(Exception):
    pass


class UserService:
    TEMPORARY_TOKEN_REGISTRATION_PREFIX = "temporary-token:registrations:"

    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        return bcrypt.checkpw(plain_password.encode(), hashed_password.encode())

    def hash_password(self, password: str) -> str:
        """
        Args:
            password:

        Returns:
            A string like '$2b$12$yadYxE5ZNfF28M.M00gha.SEaPF2Z.ICEqgIhbhZrgCrCR7PEK7uS'
        """
        return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()

    def temporary_token_generate(
        self,
        key_prefix: str,
        email: str,
        ttl_seconds: int = settings.PRE_REGISTRATION_TOKEN_TTL_SECONDS,
    ) -> str:
        """
        Generates a temporary token and stores it in the cache for an email

        Returns:
            Temporary token
        """
        token = uuid.uuid4().hex
        get_redis().set(key_prefix + email, token, ex=ttl_seconds)
        return token

    def temporary_token_is_valid(self, key_prefix: str, email: str, token: str) -> bool:
        """
        Checks whether a temporary token is valid for a given email

        Returns:
            `True` if the token is valid
        """
        cached_token = cast(bytes, get_redis().get(key_prefix + email))
        return cached_token and cached_token.decode() == token

    def temporary_token_exists(self, key_prefix: str, email: str) -> bool:
        """
        Args:
            email:

        Returns:
            ``True`` if a temporary token exists for the provided email
        """
        return get_redis().exists(key_prefix + email)

    def pre_register_user(self, email: str) -> str:
        """
        Args:
            email:

        Returns:
            A temporary token that can be used to register a new user.

        Raises:
            TemporaryTokenExists: if a temporary token already exists for the email
        """

        if self.temporary_token_exists(self.TEMPORARY_TOKEN_REGISTRATION_PREFIX, email):
            raise TemporaryTokenExists(f"Temporary token exists for {email}")
        token = self.temporary_token_generate(
            self.TEMPORARY_TOKEN_REGISTRATION_PREFIX, email
        )
        email_provider = EmailProvider()
        email_provider.send_temporary_token_email(email, token)
        return token

    async def register_user(self, email: str, password: str, token: str) -> str:
        """
        Args:
            email:
            password:
            token: Temporary token generated by `pre_register_user`

        Returns:
            UUID4 of the registered user

        Raises:
            TemporaryTokenNotValid: if the temporary token is not valid
        """

        if not self.temporary_token_is_valid(
            self.TEMPORARY_TOKEN_REGISTRATION_PREFIX, email, token
        ):
            raise TemporaryTokenNotValid(f"Temporary token not valid for {email}")
        hashed_password = self.hash_password(password)
        user_uuid = uuid.uuid4().hex
        user = Users(id=user_uuid, email=email, hashed_password=hashed_password)
        await user.create()
        return user_uuid
