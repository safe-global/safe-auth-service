import uuid
from typing import cast

from ..config import settings
from ..datasources.cache.redis import get_redis
from ..datasources.db.models import Users
from ..datasources.email.email_provider import send_temporary_token_email
from .password_service import hash_password


class TemporaryTokenNotValid(Exception):
    pass


class TemporaryTokenExists(Exception):
    pass


def temporary_token_generate(
    email: str, ttl_seconds: int = settings.PRE_REGISTRATION_TOKEN_TTL_SECONDS
) -> str:
    """
    Generates a temporary token and stores it in the cache for an email

    Returns:
        Temporary token
    """
    token = uuid.uuid4().hex
    get_redis().set("temporary-token:" + email, token, ex=ttl_seconds)
    return token


def temporary_token_is_valid(email: str, token: str) -> bool:
    """
    Checks whether a temporary token is valid for a given email

    Returns:
        `True` if the token is valid
    """
    cached_token = cast(bytes, get_redis().get("temporary-token:" + email))
    return cached_token and cached_token.decode() == token


def temporary_token_exists(email: str) -> bool:
    """
    Args:
        email:

    Returns:
        ``True`` if a temporary token exists for the providen email
    """
    return get_redis().exists("temporary-token:" + email)


def pre_register_user(email: str) -> str:
    """
    Args:
        email:

    Returns:
        A temporary token that can be used to register a new user.

    Raises:
        TemporaryTokenExists: if a temporary token already exists for the email
    """

    if temporary_token_exists(email):
        raise TemporaryTokenExists(f"Temporary token exists for {email}")
    token = temporary_token_generate(email)
    send_temporary_token_email(email, token)
    return token


async def register_user(email: str, password: str, token: str) -> str:
    """
    Args:
        email:
        password:
        token: Temporary token generated by `pre_register_user`

    Returns:
        UUID4 of the registered user

    Raises:
        TemporaryTokenNotValid: if the temporary token is not valid
    """

    if not temporary_token_is_valid(email, token):
        raise TemporaryTokenNotValid(f"Temporary token not valid for {email}")
    hashed_password = hash_password(password)
    user_uuid = uuid.uuid4().hex
    user = Users(id=user_uuid, email=email, hashed_password=hashed_password)
    await user.create()
    return user_uuid
